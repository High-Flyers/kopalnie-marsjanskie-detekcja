"""Module for formatting directory generated by CVAT to YOLO format

Files in the video input category must be in the same order as the files in the CVAT dashboard.
"""

from pathlib import Path
from distutils.dir_util import copy_tree
import argparse
import shutil

from video_to_frames import cut_to_frames

VIDEO_FORMATS = (".mp4", ".avi", ".amv", ".wmv")

def format(
    video_dir: str, cvat_dir: str, output_dir: str, valid_ratio: float = 0.2
) -> None:
    video_dir: Path = Path(video_dir)
    cvat_dir: Path = Path(cvat_dir)
    output_dir: Path = Path(output_dir)

    for dirpath in (video_dir, cvat_dir, output_dir):
        if not dirpath.is_dir():
            raise ValueError(f"{dirpath} is not a valid directory path.")

    if any(file.suffix not in VIDEO_FORMATS for file in video_dir.iterdir() if file.is_file()):
        raise ValueError(f"Files inside {video_dir} must be in one of {VIDEO_FORMATS} formats.")

    _validate_cvat_dir(cvat_dir)

    img_dir = output_dir / "images"
    img_dir.mkdir()
    img_dir_train = img_dir / "train"
    img_dir_train.mkdir()
    img_dir_valid = img_dir / "valid"
    img_dir_valid.mkdir()

    labels_dir = output_dir / "labels"
    labels_dir.mkdir()
    labels_dir_train = labels_dir / "train"
    labels_dir_train.mkdir()
    labels_dir_valid = labels_dir / "valid"
    labels_dir_valid.mkdir()

    copy_tree(
        (cvat_dir / "obj_train_data").absolute().as_posix(),
        labels_dir_train.absolute().as_posix(),
    )  # copies frame txt files into labels directory

    video_files_in_order = sorted(video_dir.iterdir())

    count = 0
    for video in video_files_in_order:
        frames_number = cut_to_frames(
            video.absolute().as_posix(),
            img_dir_train.absolute().as_posix(),
            count_from=count,
        )
        count += frames_number
    count -= 1

    valid_files_number = int(count * valid_ratio)
    for number in range(valid_files_number):
        filename = f"frame_{(count - number):06}"
        shutil.move(
            (img_dir_train / (filename + ".jpg")).absolute().as_posix(),
            (img_dir_valid / (filename + ".jpg")).absolute().as_posix(),
        )
        shutil.move(
            (labels_dir_train / (filename + ".txt")).absolute().as_posix(),
            (labels_dir_valid / (filename + ".txt")).absolute().as_posix(),
        )

    create_yaml_file(cvat_dir, output_dir)


def create_yaml_file(
    cvat_dir: Path, output_dir: Path, name: str = "model_v8.yaml"
) -> None:
    path = output_dir.absolute().as_posix()

    class_names = []
    with (cvat_dir / "obj.names").open() as file:
        class_names = file.readlines()

    content = f"""path: {path}
train: images/train
val: images/valid

names:
"""
    for idx, name in enumerate(class_names):
        content += f"  {idx}: {name}"

    with open(f"{output_dir}/model_v8.yaml", "w") as file:
        file.write(content)
    
def _validate_cvat_dir(cvat_dir: Path) -> None:
    if not any(file.match("*/obj.names") for file in cvat_dir.iterdir()):
        raise ValueError(f"{cvat_dir} doesn't contain required obj.names file.")
    if not any(file.match("*/obj_train_data") for file in cvat_dir.iterdir()): 
        raise ValueError(f"{cvat_dir} doesn't contain required obj_train_data directory.")
    if not all(file.match("*/frame_[0-9][0-9][0-9][0-9][0-9][0-9].txt") for file in (cvat_dir / "obj_train_data").iterdir()):
        raise ValueError(f"Frame files {cvat_dir / 'obj_train_data'} are named incorrectly.")
        


if __name__ == "__main__":
    a = argparse.ArgumentParser()
    a.add_argument("--video", help="path to directory with video files")
    a.add_argument("--cvat", help="path to directory with data exported by CVAT")
    a.add_argument("--output", help="path to output directory")
    args = a.parse_args()
    try:
        format(args.video, args.cvat, args.output)
    except ValueError as e:
        print(e)
